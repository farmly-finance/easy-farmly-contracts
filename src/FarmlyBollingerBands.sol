pragma solidity ^0.8.13;

import {AutomationCompatibleInterface} from "chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";
import {AggregatorV3Interface} from "chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";
import {FarmlyFullMath} from "./libraries/FarmlyFullMath.sol";

contract FarmlyBollingerBands is AutomationCompatibleInterface {
    AggregatorV3Interface public dataFeed =
        AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);

    uint16 public ma = 20;
    int16 public multiplier = 3;
    uint256 public period = 1 hours;
    int256[] public answers;
    uint256 public nextPeriodStartTimestamp;
    int256 public latestUpperBand;
    int256 public latestSma;
    int256 public latestLowerBand;

    event NewBand(
        int256 answer,
        int256 upperBand,
        int256 sma,
        int256 lowerBand,
        uint256 timestamp
    );

    constructor() {
        nextPeriodStartTimestamp = 1727636400;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory performData)
    {
        if (block.timestamp >= nextPeriodStartTimestamp) {
            (, int256 answer, , , ) = dataFeed.latestRoundData();
            performData = abi.encode(answer);
            upkeepNeeded = true;
        }
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata performData) external override {
        int256 answer = abi.decode(performData, (int256));
        answers.push(answer);
        if (answers.length >= ma) {
            (
                int256 upperBand,
                int256 sma,
                int256 lowerBand
            ) = calculateBollingerBands();

            latestUpperBand = upperBand;
            latestSma = sma;
            latestLowerBand = lowerBand;

            emit NewBand(
                answer,
                upperBand,
                sma,
                lowerBand,
                nextPeriodStartTimestamp
            );
        }
        nextPeriodStartTimestamp += period;
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    function calculateSMA() internal view returns (int256) {
        int256 sum = 0;
        for (uint256 i = answers.length - ma; i < answers.length; i++) {
            sum += answers[i];
        }
        return sum / int16(ma);
    }

    function calculateStdDev(int256 sma) internal view returns (int256) {
        uint256 variance = 0;
        for (uint256 i = answers.length - ma; i < answers.length; i++) {
            int256 diff = int256(answers[i]) - sma;
            variance += uint256(diff * diff);
        }
        return int256(FarmlyFullMath.sqrt(variance / ma));
    }

    function calculateBollingerBands()
        internal
        view
        returns (int256 upperBand, int256 sma, int256 lowerBand)
    {
        sma = calculateSMA();
        int256 stdDev = calculateStdDev(sma);

        upperBand = sma + (multiplier * stdDev);
        lowerBand = sma - (multiplier * stdDev);
    }
}
